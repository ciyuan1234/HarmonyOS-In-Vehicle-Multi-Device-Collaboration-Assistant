/**
 * éŸ³ä¹é¢æ¿ç»„ä»¶
 * 
 * åŠŸèƒ½æè¿°ï¼š
 * 1. æ˜¾ç¤ºéŸ³ä¹æ’­æ”¾çŠ¶æ€
 * 2. å“åº”æ’­æ”¾/æš‚åœæŒ‡ä»¤
 * 3. æ¨¡æ‹Ÿæ­Œæ›²ä¿¡æ¯å±•ç¤º
 * 
 * @author è½¦è½½å¤šè®¾å¤‡ååŒåŠ©æ‰‹é¡¹ç›®ç»„
 */

import { hilog } from '@kit.PerformanceAnalysisKit';

/**
 * éŸ³ä¹æ’­æ”¾çŠ¶æ€æ¥å£
 */
interface MusicState {
  isPlaying: boolean;       // æ’­æ”¾çŠ¶æ€
  songTitle: string;        // æ­Œæ›²æ ‡é¢˜
  artist: string;           // æ­Œæ‰‹
  album: string;            // ä¸“è¾‘
  progress: number;         // æ’­æ”¾è¿›åº¦ (0-100)
  volume: number;           // éŸ³é‡ (0-100)
}

@Component
export struct MusicPanel {
  @State musicState: MusicState = {
    isPlaying: false,
    songTitle: 'è¯·é€‰æ‹©æ­Œæ›²',
    artist: 'æœªçŸ¥æ­Œæ‰‹',
    album: 'æœªçŸ¥ä¸“è¾‘',
    progress: 0,
    volume: 60
  };
  
  private progressTimer: number | null = null;
  private readonly TAG: string = 'MusicPanel';
  
  build() {
    Column() {
      // é¢æ¿æ ‡é¢˜
      Row() {
        Text('ğŸµ éŸ³ä¹æ’­æ”¾å™¨')
          .fontSize(20)
          .fontWeight(FontWeight.Bold)
          .fontColor('#FFFFFF')
        
        Blank()
        
        // æ’­æ”¾çŠ¶æ€æŒ‡ç¤ºå™¨
        If (this.musicState.isPlaying) {
          Row() {
            Circle()
              .width(12)
              .height(12)
              .fill('#4CAF50')
              .margin({ right: 8 })
            
            Text('æ’­æ”¾ä¸­')
              .fontSize(14)
              .fontColor('#4CAF50')
          }
        }
      }
      .width('100%')
      .padding({ bottom: 16 })
      
      // ä¸“è¾‘å°é¢åŒºåŸŸ
      Column() {
        Circle()
          .width(120)
          .height(120)
          .fill(this.musicState.isPlaying ? '#4CAF50' : '#666666')
        
        // æ­Œæ›²ä¿¡æ¯
        Column() {
          Text(this.musicState.songTitle)
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor('#FFFFFF')
            .margin({ top: 16, bottom: 4 })
            .maxLines(1)
            .textOverflow({ overflow: TextOverflow.Ellipsis })
          
          Text(`${this.musicState.artist} - ${this.musicState.album}`)
            .fontSize(14)
            .fontColor('#AAAAAA')
            .maxLines(1)
            .textOverflow({ overflow: TextOverflow.Ellipsis })
        }
        .width('100%')
        .padding({ top: 16 })
      }
      .width('100%')
      .padding({ bottom: 20 })
      
      // è¿›åº¦æ¡
      Column() {
        Row() {
          Text(this.formatTime(this.musicState.progress))
            .fontSize(12)
            .fontColor('#AAAAAA')
          
          Blank()
          
          Text(this.formatTime(100))
            .fontSize(12)
            .fontColor('#AAAAAA')
        }
        .width('100%')
        .padding({ bottom: 8 })
        
        ProgressBar({ value: this.musicState.progress, total: 100 })
          .width('100%')
          .height(4)
          .color('#4CAF50')
          .backgroundColor('#333333')
      }
      .width('100%')
      .padding({ bottom: 20 })
      
      // æ§åˆ¶æŒ‰é’®
      Row() {
        // ä¸Šä¸€é¦–
        Button('â®')
          .width(50)
          .height(50)
          .backgroundColor('#333333')
          .fontColor('#FFFFFF')
          .borderRadius(25)
          .margin({ right: 16 })
          .onClick(() => {
            this.previousSong();
          })
        
        // æ’­æ”¾/æš‚åœ
        Button(this.musicState.isPlaying ? 'â¸' : 'â–¶')
          .width(60)
          .height(60)
          .backgroundColor('#4CAF50')
          .fontColor('#FFFFFF')
          .borderRadius(30)
          .margin({ left: 16, right: 16 })
          .onClick(() => {
            this.togglePlayPause();
          })
        
        // ä¸‹ä¸€é¦–
        Button('â­')
          .width(50)
          .height(50)
          .backgroundColor('#333333')
          .fontColor('#FFFFFF')
          .borderRadius(25)
          .margin({ left: 16 })
          .onClick(() => {
            this.nextSong();
          })
      }
      .width('100%')
      .justifyContent(FlexAlign.Center)
      .padding({ bottom: 20 })
      
      // éŸ³é‡æ§åˆ¶
      Column() {
        Row() {
          Text('ğŸ”Š éŸ³é‡')
            .fontSize(14)
            .fontColor('#AAAAAA')
            .layoutWeight(1)
          
          Text(`${this.musicState.volume}%`)
            .fontSize(14)
            .fontColor('#FFFFFF')
        }
        .width('100%')
        .padding({ bottom: 8 })
        
        Slider({
          value: this.musicState.volume,
          min: 0,
          max: 100,
          style: SliderStyle.OutSet
        })
        .width('100%')
        .onChange((value: number) => {
          this.adjustVolume(Math.round(value));
        })
      }
      .width('100%')
    }
    .width('100%')
    .backgroundColor('#1E1E1E')
    .borderRadius(16)
    .padding(20)
  }
  
  /**
   * åˆ‡æ¢æ’­æ”¾/æš‚åœçŠ¶æ€
   */
  togglePlayPause(): void {
    this.musicState = {
      ...this.musicState,
      isPlaying: !this.musicState.isPlaying
    };
    
    if (this.musicState.isPlaying) {
      this.startProgressTimer();
      hilog.info(0x0000, this.TAG, 'Music playback started');
    } else {
      this.stopProgressTimer();
      hilog.info(0x0000, this.TAG, 'Music playback paused');
    }
  }
  
  /**
   * ä¸Šä¸€é¦–æ­Œæ›²
   */
  private previousSong(): void {
    const songs = this.getSongLibrary();
    const currentIndex = songs.findIndex(song => 
      song.title === this.musicState.songTitle);
    const prevIndex = currentIndex > 0 ? currentIndex - 1 : songs.length - 1;
    const prevSong = songs[prevIndex];
    
    this.updateSong(prevSong);
    hilog.info(0x0000, this.TAG, 'Previous song selected: %{public}s', prevSong.title);
  }
  
  /**
   * ä¸‹ä¸€é¦–æ­Œæ›²
   */
  private nextSong(): void {
    const songs = this.getSongLibrary();
    const currentIndex = songs.findIndex(song => 
      song.title === this.musicState.songTitle);
    const nextIndex = (currentIndex + 1) % songs.length;
    const nextSong = songs[nextIndex];
    
    this.updateSong(nextSong);
    hilog.info(0x0000, this.TAG, 'Next song selected: %{public}s', nextSong.title);
  }
  
  /**
   * æ›´æ–°å½“å‰æ­Œæ›²
   */
  private updateSong(song: any): void {
    this.musicState = {
      ...this.musicState,
      songTitle: song.title,
      artist: song.artist,
      album: song.album,
      progress: 0
    };
    
    // å¦‚æœæ­£åœ¨æ’­æ”¾ï¼Œé‡æ–°å¼€å§‹è¿›åº¦è®¡æ—¶
    if (this.musicState.isPlaying) {
      this.stopProgressTimer();
      this.startProgressTimer();
    }
  }
  
  /**
   * è°ƒæ•´éŸ³é‡
   */
  private adjustVolume(volume: number): void {
    this.musicState = {
      ...this.musicState,
      volume: volume
    };
    hilog.info(0x0000, this.TAG, 'Volume adjusted to: %{public}d%%', volume);
  }
  
  /**
   * å¼€å§‹è¿›åº¦è®¡æ—¶å™¨
   */
  private startProgressTimer(): void {
    this.progressTimer = setInterval(() => {
      if (this.musicState.progress < 100) {
        this.musicState = {
          ...this.musicState,
          progress: this.musicState.progress + 1
        };
      } else {
        // æ­Œæ›²æ’­æ”¾å®Œæ¯•ï¼Œè‡ªåŠ¨æ’­æ”¾ä¸‹ä¸€é¦–
        this.nextSong();
      }
    }, 500); // æ¯500msæ›´æ–°ä¸€æ¬¡è¿›åº¦
  }
  
  /**
   * åœæ­¢è¿›åº¦è®¡æ—¶å™¨
   */
  private stopProgressTimer(): void {
    if (this.progressTimer) {
      clearInterval(this.progressTimer);
      this.progressTimer = null;
    }
  }
  
  /**
   * æ ¼å¼åŒ–æ—¶é—´æ˜¾ç¤º
   */
  private formatTime(progress: number): string {
    const totalSeconds = 240; // å‡è®¾æ¯é¦–æ­Œ4åˆ†é’Ÿ
    const currentSeconds = Math.floor((progress / 100) * totalSeconds);
    const minutes = Math.floor(currentSeconds / 60);
    const seconds = currentSeconds % 60;
    return `${minutes}:${seconds.toString().padStart(2, '0')}`;
  }
  
  /**
   * è·å–æ­Œæ›²åº“ï¼ˆæ¨¡æ‹Ÿæ•°æ®ï¼‰
   */
  private getSongLibrary(): Array<{title: string, artist: string, album: string}> {
    return [
      { title: 'å¤œæ›²', artist: 'å‘¨æ°ä¼¦', album: 'åä¸€æœˆçš„è§é‚¦' },
      { title: 'é’èŠ±ç“·', artist: 'å‘¨æ°ä¼¦', album: 'æˆ‘å¾ˆå¿™' },
      { title: 'ç¨»é¦™', artist: 'å‘¨æ°ä¼¦', album: 'é­”æ°åº§' },
      { title: 'å‘Šç™½æ°”çƒ', artist: 'å‘¨æ°ä¼¦', album: 'å‘¨æ°ä¼¦çš„åºŠè¾¹æ•…äº‹' },
      { title: 'ç®€å•çˆ±', artist: 'å‘¨æ°ä¼¦', album: 'èŒƒç‰¹è¥¿' }
    ];
  }
  
  /**
   * è®¾ç½®æ’­æ”¾çŠ¶æ€ï¼ˆå¤–éƒ¨è°ƒç”¨ï¼‰
   */
  setPlayState(isPlaying: boolean): void {
    if (isPlaying !== this.musicState.isPlaying) {
      this.musicState = {
        ...this.musicState,
        isPlaying: isPlaying
      };
      
      if (isPlaying) {
        this.startProgressTimer();
      } else {
        this.stopProgressTimer();
      }
    }
  }
  
  /**
   * ç»„ä»¶é”€æ¯æ—¶æ¸…ç†èµ„æº
   */
  aboutToDisappear(): void {
    this.stopProgressTimer();
  }
}